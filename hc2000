#!/usr/bin/python

import argparse
import boto.ec2
import boto.ec2.autoscale
import boto.ec2.blockdevicemapping
import email.mime.base
import email.mime.multipart
import re
import os
import os.path
import sys
import yaml

def _load_definition(filename):
    try:
        with open(filename) as f:
            sys.stdout.write('Loading %s...' % filename)
            sys.stdout.flush()

            definition = yaml.safe_load(f)

        sys.stdout.write(' [ OK ]\n')
        return definition

    except IOError as err:
        pass

def _merge_definition(definition, new):
    if new is not None:
        definition.update(new)

# xl for translate, xf for transform.
def _xl_if(condition, xl_if_true, xl_if_false):
    def _if(destination, value):
        if condition(value):
            xl_if_true(destination, value)
        else:
            xl_if_false(destination, value)

    return _if

def _xf_match(pattern):
    regex = re.compile(pattern)
    def _match(value):
        return regex.match(value)

    return _match

def _xl_set_key(key, transform=None):
    def _set_key_transform(destination, value):
        destination[key] = transform(value)

    def _set_key(destination, value):
        destination[key] = value

    return _set_key \
            if transform is None \
            else _set_key_transform

def _xl_for_each(action):
    def _for_each(destination, value):
        if isinstance(value, basestring):
            action(destination, value)
        else:
            for v in value:
                action(destination, v)

    return _for_each

def _xl_append_to_key(key):
    def _append_to_key(destination, value):
        if key in destination:
            destination[key].append(value)
        else:
            destination[key] = [ value ]

    return _append_to_key

def _xl_switch(options):
    def _switch(destination, value):
        for regex, action in options.iteritems():
            if re.match(regex, value):
                action(destination, value)
                return

    return _switch

def _xl_set_value(key, value):
    def _set_value(destination, _):
        destination[key] = value

    return _set_value

def _xl_join(key, string=','):
    def _join(destination, value):
        if isinstance(value, basestring):
            value = [ value ]
        destination[key] = string.join(value)

    return _join

def _apply_mapping(mapping, result, value):
    if hasattr(mapping, '__iter__'):
        for m in mapping:
            _apply_mapping(m, result, value)
    else:
        mapping(result, value)

def _apply_defaults(defaults, source):
    if hasattr(defaults, 'iteritems'):
        for k, v in defaults.iteritems():
            if k not in source:
                source[k] = v

_resolvable_prefixes = ('image:', 'kernel:', 'key:', 'load-balancers:',
    'ramdisk:', 'security-groups:', 'spot-price:', 'subnet:')

def _translate(mappings, source):
    result = {}
    if '~defaults~' in mappings:
        _apply_defaults(mappings['~defaults~'], source)
    for key, value in source.iteritems():
        if key in mappings:
            _apply_mapping(mappings[key], result, value)
        elif not key.startswith(_resolvable_prefixes):
            print "Unknown or unsupported option in source: %s (%s)" \
                    % (key, value)
    return result

ec2_block_device_mapping = {
    '~defaults~':   { 'disposable': True },
    'source':       _xl_switch({
                        'no-device':            _xl_set_value('no_device', True),
                        'ephemeral[0-9]':       _xl_set_key('ephemeral_name'),
                        'snap-[a-fA-F0-9]*':    _xl_set_key('snapshot_id'),
                    }),
    'size':         _xl_set_key('size'),
    'iops':         [
                        _xl_set_key('iops'),
                        _xl_set_value('volume_type', 'io1')
                    ],
    'disposable':   _xl_set_key('delete_on_termination'),
}

# For BlockDeviceMappings in LaunchConfigurations, use AWS parameter names
# directly to work around boto bug
as_block_device_mapping = {
    'source':       _xl_switch({
                        'ephemeral[0-9]':       _xl_set_key('VirtualName'),
                        'snap-[a-fA-F0-9]*':    _xl_set_key('Ebs.SnapshotId'),
                    }),
    'size':         _xl_set_key('Ebs.VolumeSize'),
}

def _xl_ec2_block_devices(key):
    def _block_devices(destination, value):
        bdm = boto.ec2.blockdevicemapping.BlockDeviceMapping()
        for k, v in value.iteritems():
            params = _translate(ec2_block_device_mapping, v)
            bdm[k] = boto.ec2.blockdevicemapping.BlockDeviceType(**params)
        destination[key] = bdm

    return _block_devices

def _xl_as_block_devices(key):
    def _block_devices(destination, value):
        mappings = []
        for k, v in value.iteritems():
            # boto.ec2.autoscale.launchconfig.BlockDeviceMapping does not get
            # properly propagated to API call
            bdm = _translate(as_block_device_mapping, v)
            bdm['DeviceName'] = k
            mappings.append(bdm)
        destination[key] = mappings

    return _block_devices

_magic_to_mime = {
    '#!':               ('text', 'x-shellscript'),
    '#cloud-boothook':  ('text', 'cloud-boothook'),
    '#cloud-config':    ('text', 'cloud-config'),
    '#include':         ('text', 'x-include-url'),
    '#part-handler':    ('text', 'part-handler'),
    '#puppet':          ('text', 'puppet'),
    '#upstart-job':     ('text', 'upstart-job'),
}

def _xl_user_data(key):
    def _user_data_file(filename):
        with open(filename, 'rb') as f:
            return _user_data_entry(f.read())

    def _user_data_entry(value):
        if value.startswith('file:'):
            return _user_data_file(value[5:])

        maintype, subtype = ('application', 'octet-stream')
        for magic, mime in _magic_to_mime.iteritems():
            if value.startswith(magic):
                maintype, subtype = mime
                break
        if maintype == 'text':
            msg = email.mime.text.MIMEText(value, subtype)
        else:
            msg = email.mime.base.MIMEBase(maintype, subtype)
            msg.set_payload(value)
        msg.add_header('Content-Disposition', 'attachment')
        return msg

    def _user_data(destination, value):
        if isinstance(value, basestring) \
                or not hasattr(value, '__iter__'):
            destination[key] = value
            return

        data = email.mime.multipart.MIMEMultipart()
        for d in value:
            data.attach(_user_data_entry(d))
        destination[key] = data.as_string()

    return _user_data

# boto.ec2.autoscale.Tag unconditionally outputs optional parameters ResourceId
# and ResourceType, requiring them to be set. _Tag works around that
# constraint.
class _Tag:
    def __init__(self, key, value):
        self.key = key
        self.value = value

    def build_params(self, params, i):
        prefix = 'Tags.member.%d.' % i
        params[prefix + 'Key'] = self.key
        params[prefix + 'Value'] = self.value

def _xl_as_tags(destination, value):
    tags = []
    for k, v in value.iteritems():
        tags.append(_Tag(k, v))
    destination['tags'] = tags

run_instances_mapping = {
    'instance-type':        _xl_set_key('instance_type'),
    'ebs-optimized':        _xl_set_key('ebs_optimized'),
    'block-devices':        _xl_ec2_block_devices('block_device_map'),
    'image':                _xl_set_key('image_id'),
    'kernel':               _xl_set_key('kernel_id'),
    'ramdisk':              _xl_set_key('ramdisk_id'),
    'min-count':            _xl_set_key('min_count'),
    'max-count':            _xl_set_key('max_count'),
    'count':                _xl_set_key('max_count'),
    'key':                  _xl_set_key('key_name'),
    'role':                 _xl_if(_xf_match('arn:aws:iam::'),
                                _xl_set_key('instance_profile_arn'),
                                _xl_set_key('instance_profile_name')),
    'security-groups':      _xl_for_each(
                                _xl_if(_xf_match('sg-[0-9A-Fa-f]+$'),
                                    _xl_append_to_key('security_group_ids'),
                                    _xl_append_to_key('security_groups'))),
    'subnet':               _xl_set_key('subnet_id'),
    'ip-address':           _xl_set_key('private_ip_address'),
    'availability-zone':    _xl_set_key('placement'),
    'placement-group':      _xl_set_key('placement_group'),
    'tenancy':              _xl_set_key('tenancy'),
    'user-data':            _xl_user_data('user_data'),
    'monitoring':           _xl_set_key('monitoring_enabled'),
    'api-termination':      _xl_set_key('disable_api_termination', lambda x: not x),
    'shutdown-behavior':    _xl_set_key('instance_initiated_shutdown_behavior'),
    'client-token':         _xl_set_key('client_token'),
}

spot_request_mapping = run_instances_mapping.copy()
# RunInstance arguments not supported in SpotRequests
for key in [ 'min-count', 'max-count', 'ip-address', 'tenancy',
        'api-termination', 'shutdown-behavior', 'client-token' ]:
    del spot_request_mapping[key]
# Configuration specific to SpotRequests
spot_request_mapping.update({
    'spot-price':               _xl_set_key('price'),
    'spot-request-type':        _xl_set_key('type'),
    'valid-from':               _xl_set_key('valid_from'),
    'valid-until':              _xl_set_key('valid_until'),
    'launch-group':             _xl_set_key('launch_group'),
    'availability-zone-group':  _xl_set_key('availability_zone_group'),
})

launch_configuration_mapping = {
    'launch-configuration':     _xl_set_key('name'),
    'instance-type':            _xl_set_key('instance_type'),
    'spot-price':               _xl_set_key('spot_price'),
    'image':                    _xl_set_key('image_id'),
    'kernel':                   _xl_set_key('kern_id'),
    'ramdisk':                  _xl_set_key('ramdisk_id'),
    'key':                      _xl_set_key('key_name'),
    'role':                     _xl_set_key('instance_profile_name'),
    'security-groups':          _xl_for_each(_xl_append_to_key('security_groups')),
    'user-data':                _xl_user_data('user_data'),
    'monitoring':               _xl_set_key('instance_monitoring'),
    'ebs-optimized':            _xl_set_key('ebs_optimized'),
    'block-devices':            _xl_as_block_devices('block_device_mappings'),
}

auto_scaling_group_mapping = {
    'auto-scaling-group':           _xl_set_key('name'),
    'launch-configuration':         _xl_set_key('launch_config'),
    'count':                        _xl_set_key('desired_capacity'),
    'min-count':                    _xl_set_key('min_size'),
    'max-count':                    _xl_set_key('max_size'),
    'subnet':                       _xl_join('vpc_zone_identifier'),
    'availability-zone':            _xl_set_key('availability_zones'),
    'auto-scaling-cooldown':        _xl_set_key('default_cooldown'),
    'auto-scaling-grace-period':    _xl_set_key('health_check_period'),
    'auto-scaling-health-check':    _xl_set_key('health_check_type'),
    'load-balancers':               _xl_set_key('load_balancers'),
    'tags':                         _xl_as_tags,
    'termination-policies':         _xl_set_key('termination_policies'),
}

# Launch Configurations and Auto-Scaling Groups are meant to share
# configuration, so have them ignore each other's keys.
launch_configuration_keys = launch_configuration_mapping.keys()
auto_scaling_group_keys = auto_scaling_group_mapping.keys()

for key in auto_scaling_group_keys:
    if key not in launch_configuration_mapping:
        launch_configuration_mapping[key] = lambda x, y: None
for key in launch_configuration_keys:
    if key not in auto_scaling_group_mapping:
        auto_scaling_group_mapping[key] = lambda x, y: None

    # TODO: NetworkInterface

def _resolve_symbolic_values(definition):
    def _resolve_symbol(value):
        visited = set()
        while isinstance(value, basestring) \
                and value.startswith(prefix):
            value = value.format(**definition)
            if value in definition \
                    and value not in visited:
                visited.add(value)
                value = definition[value]
        return value

    for prefix in _resolvable_prefixes:
        key = prefix[:-1]
        if key not in definition:
            continue

        if isinstance(definition[key], basestring):
            definition[key] = _resolve_symbol(definition[key])
        elif isinstance(definition[key], list):
            definition[key] = [ _resolve_symbol(v) for v in definition[key] ]

def load_instance_definition(config):
    instance = {}
    for path in config.instance_path:
        path = path.format(region=config.region)
        _merge_definition(instance,
                _load_definition(os.path.join(path, '~default~')))
        _merge_definition(instance,
                _load_definition(os.path.join(path, config.instance)))
    _resolve_symbolic_values(instance)
    return instance

def launch_action(config):
    instance = load_instance_definition(config)

    def command_line_override(option, key):
        if hasattr(config, option):
            instance[key] = getattr(config, option)

    command_line_override('client_token', 'client-token')
    command_line_override('instance_count', 'count')
    command_line_override('subnet', 'subnet')
    command_line_override('availability_zone', 'availability-zone')

    # FIXME: This should live as some sort of external plugin.
    if 'puppet' in instance:
        if 'user-data' not in instance:
            instance['user-data'] = []
        elif isinstance(instance['user-data'], basestring):
            instance['user-data'] = [ instance['user-data'] ]

        def _include_puppet(destination, value):
            orig_value = value
            if not value.endswith('.pp'):
                value = value + '.pp'
            found = False
            for path in config.puppet_path:
                path = os.path.join(path, value)
                if os.path.exists(path):
                    destination['user-data'].append('file:' + path)
                    found = True
            if not found:
                print 'Couldn\'t find manifest for \'%s\'' % orig_value

        instance['user-data'].append('file:handlers/puppet.py')
        _xl_for_each(_include_puppet)(instance, instance['puppet'])

        del instance['puppet']

    if 'auto-scaling-group' in instance:
        _do_auto_scaling(config, instance)
    elif 'spot-price' in instance:
        _do_spot_request(config, instance)
    else:
        _do_run_instance(config, instance)

def _do_run_instance(config, definition):
    ec2 = boto.ec2.connect_to_region(config.region,
            aws_access_key_id=config.aws_access_key,
            aws_secret_access_key=config.aws_secret_key)

    params = _translate(run_instances_mapping, definition)
    print ec2.run_instances(**params)

def _do_spot_request(config, definition):
    ec2 = boto.ec2.connect_to_region(config.region,
            aws_access_key_id=config.aws_access_key,
            aws_secret_access_key=config.aws_secret_key)

    params = _translate(spot_request_mapping, definition)
    print ec2.request_spot_instances(**params)

def _do_auto_scaling(config, definition):
    autoscale = boto.ec2.autoscale.connect_to_region(config.region,
            aws_access_key_id=config.aws_access_key,
            aws_secret_access_key=config.aws_secret_key)

    launcher = autoscale.get_all_launch_configurations(names=[ definition['launch-configuration'] ])
    if len(launcher) == 0:
        params = _translate(launch_configuration_mapping, definition)
        print "Launch configuration:", params
        launcher = boto.ec2.autoscale.launchconfig.LaunchConfiguration(autoscale, **params)
        print autoscale.create_launch_configuration(launcher)

    group = autoscale.get_all_groups(names=[ definition['auto-scaling-group'] ])
    if len(group) == 0:
        params = _translate(auto_scaling_group_mapping, definition)
        print "Auto scaling groups:", params
        group = boto.ec2.autoscale.group.AutoScalingGroup(autoscale, **params)
        print autoscale.create_auto_scaling_group(group)

    # TODO: Handle load balancers
    # TODO: Handle updates to both launch configuration and group

def parse_args(args=None):
    parser = argparse.ArgumentParser(fromfile_prefix_chars='@')

    parser.add_argument('-O', '--aws-access-key', metavar='<key>',
            default=os.environ.get('AWS_ACCESS_KEY'), help='AWS Access Key '
            'ID. Defaults to AWS_ACCESS_KEY environment variable, if set.')
    parser.add_argument('-W', '--aws-secret-key', metavar='<secret>',
            default=os.environ.get('AWS_SECRET_KEY'), help='AWS Secret Access '
            'Key. Defaults to AWS_SECRET_KEY environment variable, if set.')
    parser.add_argument('--region', metavar='<region>',
            default=os.environ.get('EC2_REGION'),
            required=(os.environ.get('EC2_REGION') is None), help='AWS EC2 '
            'Region. Defaults to EC2_REGION environment variable, if set.')

    parser.add_argument('--instance-path', metavar='<path>', action='append',
            help='Append path to list of instance definition search paths. If '
            'no path is specified on the command line definitions are loaded '
            'from the current directory.')
    parser.add_argument('--puppet-path', metavar='<path>', action='append',
            help='Append path to list of puppet manifest search paths. If no '
            'path is specified on the command line puppet manifests are '
            'loaded from the current directory.')

    actions = parser.add_subparsers(title='actions')

    launch = actions.add_parser('launch', argument_default=argparse.SUPPRESS)
    launch.add_argument('--client-token', metavar='<token>',
            help='User-defined token identifying the request. Use to ensure '
            'idempotent requests.')
    launch.add_argument('-n', '--instance-count', metavar='<count>',
            help='Number of instances to launch. Overrides \'count\' '
            'attribute in instance definition.')
    launch.add_argument('-s', '--subnet', metavar='<subnet>',
            help='Subnet identifier for started instances. Overrides '
            '\'subnet\' attribute in instance definition.')
    launch.add_argument('-z', '--availability-zone', metavar='<zone>',
            help='Availability zone for started instances. Overrides '
            '\'availability-zone\' attribute in instance definition.')
    launch.add_argument('instance', help='Path to instance definition file.')
    launch.set_defaults(actor=launch_action)

    return parser.parse_args(args)

def set_default_config(config):
    if config.instance_path is None:
        config.instance_path = [ '.' ]
    if config.puppet_path is None:
        config.puppet_path = [ '.' ]

if __name__ == '__main__':
    config = parse_args()
    set_default_config(config)
    config.actor(config)
