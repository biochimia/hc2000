#!/usr/bin/python

import argparse
import boto.ec2
import boto.ec2.autoscale
import re
import os
import sys
import yaml

def _load_definition(filename):
    with open(filename) as f:
        sys.stdout.write('Loading %s...' % filename)
        sys.stdout.flush()

        definition = yaml.safe_load(f)
        sys.stdout.write(' [ OK ]\n')
    return definition

# xl for translate, xf for transform.
def _xl_if(condition, xl_if_true, xl_if_false):
    def _if(destination, value):
        if condition(value):
            xl_if_true(destination, value)
        else:
            xl_if_false(destination, value)

    return _if

def _xf_match(pattern):
    regex = re.compile(pattern)
    def _match(value):
        return regex.match(value)

    return _match

def _xl_set_key(key, transform=None):
    def _set_key_transform(destination, value):
        destination[key] = transform(value)

    def _set_key(destination, value):
        destination[key] = value

    return _set_key \
            if transform is None \
            else _set_key_transform

def _xl_for_each(action):
    def _for_each(destination, value):
        if isinstance(value, basestring):
            action(destination, value)
        else:
            for v in value:
                action(destination, v)

    return _for_each

def _xl_append_to_key(key):
    def _append_to_key(destination, value):
        if key in destination:
            destination[key].append(value)
        else:
            destination[key] = [ value ]

    return _append_to_key

def _translate(mappings, source):
    result = {}
    for key, value in source.iteritems():
        if key in mappings:
            mappings[key](result, value)
        else:
            print "Unknown or unsupported option in source: %s (%s)" \
                    % (key, value)
    return result

run_instances_mapping = {
    'instance-type':        _xl_set_key('instance_type'),
    'ebs-optimized':        _xl_set_key('ebs_optimized'),
    'image':                _xl_set_key('image_id'),
    'kernel':               _xl_set_key('kernel_id'),
    'ramdisk':              _xl_set_key('ramdisk_id'),
    'min-count':            _xl_set_key('min_count'),
    'max-count':            _xl_set_key('max_count'),
    'count':                _xl_set_key('max_count'),
    'key':                  _xl_set_key('key_name'),
    'role':                 _xl_if(_xf_match('arn:aws:iam::'),
                                _xl_set_key('instance_profile_arn'),
                                _xl_set_key('instance_profile_name')),
    'security-groups':      _xl_for_each(
                                _xl_if(_xf_match('sg-[0-9A-Fa-f]+$'),
                                    _xl_append_to_key('security_group_ids'),
                                    _xl_append_to_key('security_groups'))),
    'subnet':               _xl_set_key('subnet_id'),
    'ip-address':           _xl_set_key('private_ip_address'),
    'availability-zone':    _xl_set_key('placement'),
    'placement-group':      _xl_set_key('placement_group'),
    'tenancy':              _xl_set_key('tenancy'),
    'user-data':            _xl_set_key('user_data'),
    'monitoring':           _xl_set_key('monitoring_enabled'),
    'api-termination':      _xl_set_key('disable_api_termination', lambda x: not x),
    'shutdown-behavior':    _xl_set_key('instance_initiated_shutdown_behavior'),
    'client-token':         _xl_set_key('client_token'),
}

spot_request_mapping = run_instances_mapping.copy()
# RunInstance arguments not supported in SpotRequests
for key in [ 'min-count', 'max-count', 'ip-address', 'tenancy',
        'api-termination', 'shutdown-behavior', 'client-token' ]:
    del spot_request_mapping[key]
# Configuration specific to SpotRequests
spot_request_mapping.update({
    'spot-price':               _xl_set_key('price'),
    'spot-request-type':        _xl_set_key('type'),
    'valid-from':               _xl_set_key('valid_from'),
    'valid-until':              _xl_set_key('valid_until'),
    'launch-group':             _xl_set_key('launch_group'),
    'availability-zone-group':  _xl_set_key('availability_zone_group'),
})

launch_configuration_mapping = {
    'launch-configuration':     _xl_set_key('name'),
    'instance-type':            _xl_set_key('instance_type'),
    'spot-price':               _xl_set_key('spot_price'),
    'image':                    _xl_set_key('image_id'),
    'kernel':                   _xl_set_key('kern_id'),
    'ramdisk':                  _xl_set_key('ramdisk_id'),
    'key':                      _xl_set_key('key_name'),
    'role':                     _xl_set_key('instance_profile_name'),
    'security-groups':          _xl_for_each(_xl_append_to_key('security_groups')),
    'user-data':                _xl_set_key('user_data'),
    'monitoring':               _xl_set_key('instance_monitoring'),
    'ebs-optimized':            _xl_set_key('ebs_optimized'),
}

auto_scaling_group_mapping = {
    'auto-scaling-group':           _xl_set_key('name'),
    'launch-configuration':         _xl_set_key('launch_config'),
    'count':                        _xl_set_key('desired_capacity'),
    'min-count':                    _xl_set_key('min_size'),
    'max-count':                    _xl_set_key('max_size'),
    'subnet':                       _xl_set_key('vpc_zone_identifier'),
    'availability-zone':            _xl_set_key('availability_zones'),
    'auto-scaling-cooldown':        _xl_set_key('default_cooldown'),
    'auto-scaling-grace-period':    _xl_set_key('health_check_period'),
    'auto-scaling-health-check':    _xl_set_key('health_check_type'),
    'load-balancers':               _xl_set_key('load_balancers'),
    'tags':                         _xl_set_key('tags'),
    'termination-policies':         _xl_set_key('termination_policies'),
}

# Launch Configurations and Auto-Scaling Groups are meant to share
# configuration, so have them ignore each other's keys.
launch_configuration_keys = launch_configuration_mapping.keys()
auto_scaling_group_keys = auto_scaling_group_mapping.keys()

for key in auto_scaling_group_keys:
    if key not in launch_configuration_mapping:
        launch_configuration_mapping[key] = lambda x, y: None
for key in launch_configuration_keys:
    if key not in auto_scaling_group_mapping:
        auto_scaling_group_mapping[key] = lambda x, y: None

    # TODO: BlockDeviceMapping
    # TODO: NetworkInterface

def run_action(config):
    instance = _load_definition(config.instance)

    def command_line_override(option, key):
        if hasattr(config, option):
            instance[key] = getattr(config, option)

    command_line_override('instance-count', 'count')
    command_line_override('subnet', 'subnet')
    command_line_override('availability-zone', 'availability-zone')

    if 'auto-scaling-group' in instance:
        _do_auto_scaling(config, instance)
    elif 'spot-price' in instance:
        _do_spot_request(config, instance)
    else:
        _do_run_instance(config, instance)

def _do_run_instance(config, definition):
    ec2 = boto.ec2.connect_to_region(config.region,
            aws_access_key_id=config.aws_access_key,
            aws_secret_access_key=config.aws_secret_key)

    params = _translate(run_instances_mapping, definition)
    print ec2.run_instances(**params)

def _do_spot_request(config, definition):
    ec2 = boto.ec2.connect_to_region(config.region,
            aws_access_key_id=config.aws_access_key,
            aws_secret_access_key=config.aws_secret_key)

    params = _translate(spot_request_mapping, definition)
    print ec2.request_spot_instances(**params)

def _do_auto_scaling(config, definition):
    autoscale = boto.ec2.autoscale.connect_to_region(config.region,
            aws_access_key_id=config.aws_access_key,
            aws_secret_access_key=config.aws_secret_key)

    launcher = autoscale.get_all_launch_configurations(names=[ definition['launch-configuration'] ])
    if len(launcher) == 0:
        params = _translate(launch_configuration_mapping, definition)
        print "Launch configuration:", params
        launcher = boto.ec2.autoscale.launchconfig.LaunchConfiguration(autoscale, **params)
        print autoscale.create_launch_configuration(launcher)

    group = autoscale.get_all_groups(names=[ definition['auto-scaling-group'] ])
    if len(group) == 0:
        params = _translate(auto_scaling_group_mapping, definition)
        print "Auto scaling groups:", params
        group = boto.ec2.autoscale.group.AutoScalingGroup(autoscale, **params)
        print autoscale.create_auto_scaling_group(group)

    # TODO: Handle load balancers
    # TODO: Handle updates to both launch configuration and group

def parse_args(args=None):
    parser = argparse.ArgumentParser()

    parser.add_argument('-O', '--aws-access-key', default=os.environ.get('AWS_ACCESS_KEY'),
            help='AWS Access Key ID. Defaults to AWS_ACCESS_KEY environment variable, if set.')
    parser.add_argument('-W', '--aws-secret-key', default=os.environ.get('AWS_SECRET_KEY'),
            help='AWS Secret Access Key. Defaults to AWS_SECRET_KEY environment variable, if set.')
    parser.add_argument('--region', default=os.environ.get('EC2_REGION'),
            required=(os.environ.get('EC2_REGION') is None),
            help='AWS EC2 Region. Defaults to EC2_REGION environment variable, if set.')

    actions = parser.add_subparsers(title='actions')

    run = actions.add_parser('run', argument_default=argparse.SUPPRESS)
    run.add_argument('--client-token',
            help='User-defined token identifying the request. Use to ensure idempotent requests.')
    run.add_argument('-n', '--instance-count',
            help='Number of instances to run. Overrides \'count\' attribute in instance definition.')
    run.add_argument('-s', '--subnet',
            help='Subnet identifier for started instances. Overrides \'subnet\' attribute in instance definition.')
    run.add_argument('-z', '--availability-zone',
            help='Availability zone for started instances. Overrides \'availability-zone\' attribute in instance definition.')
    run.add_argument('instance',
            help='Path to instance definition file.')
    run.set_defaults(actor=run_action)

    return  parser.parse_args(args)

if __name__ == '__main__':
    config = parse_args()
    config.actor(config)
